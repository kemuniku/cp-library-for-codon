# Template

codonの標準機能を拡張・改変するテンプレート集です。  

## [map 入力受取](./map_input.py)

- `N, M = map(int, input().split()` のような右辺mapの構文に対応します。
- アンパッキングは末尾のみ可能です。  
`N, *A = map(int, input().split())` には対応しますが、   
`*A, N = map(int, input().split())` はエラーを返します。    
この場合、右辺を`list`にキャストしてください。

## [int 除算方向変更](./int_py_floordiv.py)

- `int`と`Int[N]`の除算方向を、Python・PyPy3の負の無限大丸めに変更します。  
- floordiv`//`と、mod`%`の演算に変更を加えます。変更結果の例は後述します。
- 変更を行うと、除算の実行時間が5%ほど遅くなります。   
また、`Int[N]`で除算ができるのはN ≤ 128に限ります。
- `divmod`はこの変更の影響を受けません。

```python: codonが変更前、Pythonが除算方向変更後
print( 20 //  3,  20 %  3)  #codon: ( 6,  2), Python: ( 6,  2)
print(-20 //  3, -20 %  3)  #codon: (-6, -2), Python: (-7,  1)
print( 20 // -3,  20 % -3)  #codon: (-6,  2), Python: (-7, -1)
print(-20 // -3, -20 % -3)  #codon: ( 6, -2), Python: ( 6, -2)
```

## [int bit_length, bit_countを追加](./int_bit_length_count.py)

- `int.bit_length()`と`int.bit_count()`を追加します。   
- PyPy3の同名関数は低速でしたが、こちらは実測上高速です。

## [int ハッシュ値変更](./int_hash_splitmix64.py)

- `int`のハッシュ値を疑似乱数に変更します。  
実装上はコンパイル時乱数と[SplitMix64](https://prng.di.unimi.it/splitmix64.c)でハッシュ値を決定します。
- 現在のcodonの`set`と`dict`はハッシュ計算式の脆弱性が確認されています。   
本来は`set`と`dict`の該当箇所を改変するべきですが、改変箇所が多くなるため`int`のハッシュ値の計算式を変更して対応します。
  - 脆弱性の要約
     - int型の値nをsetに追加するとき、以下の計算式で初期アドレスiを計算します。  
ハッシュが衝突した場合、 i += 1, 2, 3, ･･･ と定数加算してアドレスを再探索します。  
       1. `k = hash(n)` : codonの標準機能では `hash(n) == n` を満たす   
       2. `i = (k >> 33) ^ k ^ (k << 11)`   
       3. `i &= mask` : 下位ビットのみを抜き出す
     - 再探索は定数加算なので、結局のところ初期アドレスiの偏り方が衝突回数に直結します。
     - ここで 0 ≤ n < $2^{33}$ の場合、b. の計算式から、iの下位11ビットはnの下位11ビットと一致します。      
敵対的攻撃の際はここを突き、入力の下位11ビットを統一すれば撃墜できます。
     - 更に、setに値の2倍, 4倍, 8倍, ･･･ を追加する状況を考えます。  
2倍が進むにつれてnの下位ビットが連続する0で偏るので、初期アドレスiも偏ってしまい、期待計算量O(1)が達成できなくなります。
  - 例題: [ABC323D](https://atcoder.jp/contests/abc323/tasks/abc323_d)

## [float 出力桁数変更](./float_str_precision.py)

- floatの出力制度を有効数字15桁にします。
- codonの標準機能ではfloatは有効数字7桁での出力となっているので、format文で15桁出力に固定します。
- ローカル環境でformat文がうまく動かない場合、[kemunikuさんの記事](https://scrapbox.io/kemuniku/codon%E3%81%A7python%E3%82%B3%E3%83%BC%E3%83%89%E3%81%8C%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E5%8B%95%E3%81%8B%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%82%82%E3%81%AE)の通り、    
`sudo locale-gen en_US.UTF-8` を実行してください。

## [pow 機能拡張](./pow_extended.py)

- 巨大mod時のオーバーフローを回避し、負の指数にも対応します。
- codonの標準機能では `pow(10 ** 10, 2, 10 ** 18) = 766279631452241920` のように、第3引数が $3×10^9$ より十分に大きいとオーバーフローしていました。   
本実装では、128bit符号つき整数内で計算することでオーバーフローを回避しています。   
ただしこれに伴い、**128bit符号つき整数の演算コストがかかるようになります**(実用上は高速です)。
- `pow(base, -1, mod)` のような、負の指数の演算機能も追加しました。
